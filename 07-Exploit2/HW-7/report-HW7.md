# Report. HW7.

## 쉘코드 삽입

아래의 3개 파일들은 공통적으로 `vuln`이란 함수를 실행한다. 이 함수를 `call`하기 전에 갖고 있는 `SFP`, 그러니까 여기선 `$ebp`의 값을 쉘코드가 위치한 곳으로 변경해야 한다. 모두 `char buf[BUF_SIZE]`란 변수가 있고, 그 뒤에 `vuln` 함수를 부르기 전 저장해 두었던 `$esp`와 `$ebp`가 차례로 **8바이트**씩(64비트 환경에서 돌려서 그렇다. 32비트라면 4바이트를 썼겠지?) 스택에 저장되어 있다. 그러니까...

|content|size|stack direction|
|:-:|:-:|:-:|
|ebp|8 byte|↓|
|esp|8 byte|(stack grows downward)|
|buf|`BUF_SIZE` byte|(smaller address value downward)|

... 형태로 스택이 쌓여있는 거다(스택은 아래 방향으로 자라며, 따라서 아래로 내려갈수록 주소값이 작아진다). 아래에 있는 `buf`에게 `BUF_SIZE`의 크기보다 더 큰 길이로 하는 문자열 값을 넘겨주면 `$esp`와 `$ebp`의 값이 바뀔 수 있을 것이다.

## `bof6`

<details><summary>bof6.c</summary>
  <p>

```c
// AFTER => bof5.c
//       => shellcode.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define BUF_SIZE 128

// ASLR OFF
// STACK-PROTECTOR OFF
// STACK-EXECUTION ON


void vuln() {
    char buf[BUF_SIZE];
    char shellcode[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05";

    printf("[shellcode:%p]\n", shellcode);
    gets(buf);
    printf("Hello %s!\n", buf);

    if (setreuid(UID_BOF7, UID_BOF7)) {
        perror("setuid");
        exit(1);
    }
    if (setregid(UID_BOF7, UID_BOF7)) {
        perror("setgid");
        exit(1);
    }
}

int main() {
    vuln();
    return 0;
}

```
</p></details>
*여기에 코드 좀 넣어줘*

`vuln` 함수 안에 쉘코드가 `char shellcode[]` 형태로 이미 들어가 있다. `vuln` 함수를 종료할 때, 갖고 오게 될 `$ebp`의 값을 이 `SHELLCODE`가 위치한 주소값을 가지게끔 조작하면 될 것이다.

## `bof7`

<details><summary>bof7.c</summary>
  <p>
    
```c
// AFTER => bof6.c
//       => shellcode.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define BUF_SIZE 128
#define R "\033[31m"
#define E "\033[0m"

// ASLR OFF
// STACK-PROTECTOR OFF
// STACK-EXECUTION ON

void vuln(char * arg){
    char buf[BUF_SIZE];

    if (setreuid(UID_BOF8, UID_BOF8)) {
        perror("setuid");
        exit(1);
    }
    if (setregid(UID_BOF8, UID_BOF8)) {
        perror("setgid");
        exit(1);
    }

    strcpy(buf, arg);
    printf("Hello %s[%p]!\n", buf, buf);
}

int main(int c, char *v[]) {
    if (c < 2) {
        fputs(R "error :( this program needs some arguments\n" E, stderr);
        return 1;
    }
    vuln(v[1]);
    return 0;
}

```
</p></details>
*여기에 코드 좀 넣어줘*

`bof6`과는 다르게 이번엔 쉘코드가 들어가 있지 않다. 막막...하긴 했는데, 그냥 내가 입력으로 쉘코드를 넣어주고, `vuln` 함수를 종료하면서 갖고오게 될 `$ebp`의 값을 내가 입력한 문자열이 위치한 주소값이 되게끔 바꾸면 된다.

## `bof8`

<details><summary>bof8.c</summary>
  </p>
  
```c
// AFTER => bof7.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define BUF_SIZE 8

// ASLR OFF
// STACK-PROTECTOR OFF
// STACK-EXECUTION ON

void vuln() {
    char buf[BUF_SIZE];

    if (setreuid(UID_BOF9, UID_BOF9)) {
        perror("setuid");
        exit(1);
    }
    if (setregid(UID_BOF9, UID_BOF9)) {
        perror("setgid");
        exit(1);
    }
    gets(buf);
    printf("Hello %s[%p]!\n", buf, buf);
    printf("(env:SHELLCODE -> %p)\n", getenv("SHELLCODE"));
}

int main() {
    vuln();
    return 0;
}

```
</p></details>
*여기에 코드 좀 넣어줘*

이번엔 환경 변수 `SHELLCODE`를 `$ebp`가 가리키게 해야 한다. 근데 환경변수 `SHELLCODE`는 어떻게 만들까? 방법은...

1. 그냥 `bof8`을 실행할 때 마다 임시 환경변수를 등록하고 실행한다. (e.g. `SHELLCODE=<shellcode_main>> ./bof8)
2. `export` 명령어로 환경변수를 한번 등록해 놓고 `bof8`을 실행한다. (e.g. `export SHELLCODE=<shellcode_main>; ./bof8`)

둘 중 하나의 방법으로 하면 될 것이다. 나는 1번의 방법을 택했다.

추가. `SHELLCODE='\x31\xc0...' ./bof8`로는 실행이 불가능하다. 이렇게 쓰면 `SHELLCODE`에 쉘코드가 그대로 들어가지 않고 *저 문자 그대로(/비슷하게)* 들어가서 쉘코드가 아닌 게 되어버린다. 그래서, *진짜* 쉘코드를 주려면, `SHELLCODE=$(python -c "print '<shellcode_main>'") ./bof8`의 형태로, 그러니까 **파이썬에서 쉘코드를 출력하여** 그걸 `SHELLCODE`에 넘겨주어야 한다.

추가 2. `bof7`의 경우 argument로 넘겨 준 문자열의 길이에 따라 `buf`의 주소값이 달라진다. 정확하게 추적하기가 쉽지 않았다.

추가 3. `set $ZF = 6`, `set $eflags |= (1 << $ZF)`를 애용해야 할 거 같다. 정상적으로 입력값/패러미터를 넘겨줘도 `setreuid` / `setregid`에서 자꾸 오류가 뜨는 분기로 튀어버리곤 하였다.

# -- END --

