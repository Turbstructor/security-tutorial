# Report. HW7.

## 쉘코드 삽입

아래의 3개 파일들은 공통적으로 `vuln`이란 함수를 실행한다. 이 함수를 `call`하기 전에 갖고 있는 `SFP`, 그러니까 여기선 `$ebp`의 값을 쉘코드가 위치한 곳으로 변경해야 한다. 모두 `char buf[BUF_SIZE]`란 변수가 있고, 그 뒤에 `vuln` 함수를 부르기 전 저장해 두었던 `$esp`와 `$ebp`가 차례로 **8바이트**씩(64비트 환경에서 돌려서 그렇다. 32비트라면 4바이트를 썼겠지?) 스택에 저장되어 있다. 그러니까...

|content|size||
|:-:|:-:|---|
|ebp|8 byte|
|esp|8 byte|↓ (stack grows downward)
|buf|`BUF_SIZE` byte|

... 형태로 스택이 쌓여있는 거다(스택은 아래 방향으로 자라며, 따라서 아래로 내려갈수록 주소값이 작아진다). 아래에 있는 `buf`에게 `BUF_SIZE`의 크기보다 더 큰 길이로 하는 문자열 값을 넘겨주면 `$esp`와 `$ebp`의 값이 바뀔 수 있을 것이다.

## `bof6`

*여기에 코드 좀 넣어줘*

`vuln` 함수 안에 쉘코드가 `char shellcode[]` 형태로 이미 들어가 있다. `vuln` 함수를 종료할 때, 갖고 오게 될 `$ebp`의 값을 이 `SHELLCODE`가 위치한 주소값을 가지게끔 조작하면 될 것이다.

## `bof7`

*여기에 코드 좀 넣어줘*

`bof6`과는 다르게 이번엔 쉘코드가 들어가 있지 않다. 막막...하긴 했는데, 그냥 내가 입력으로 쉘코드를 넣어주고, `vuln` 함수를 종료하면서 갖고오게 될 `$ebp`의 값을 내가 입력한 문자열이 위치한 주소값이 되게끔 바꾸면 된다.

## `bof8`

*여기에 코드 좀 넣어줘*

이번엔 환경 변수로 `SHELLCODE`가 있다고 생각하고 실행한다. 실행하는 줄이 좀 길어지긴 한데...

1. 그냥 `bof8`을 실행할 때 마다 임시 환경변수를 등록하고 실행한다.
2. `export` 명령어로 환경변수를 한번 등록해 놓고 `bof8`을 실행한다. (왠지 이게 더 편하지 않았을까 싶은데...)

둘 중 하나의 방법으로 하면 될 것이다. 나는 1번의 방법을 택했다.

추가. 

# -- END --

