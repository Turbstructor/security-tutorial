# Report. HW7.

## 쉘코드 삽입

아래의 3개 파일들은 공통적으로 `vuln`이란 함수를 실행한다. 이 함수를 `call`하기 전에 갖고 있는 `SFP`, 그러니까 여기선 `$ebp`의 값을 쉘코드가 위치한 곳으로 변경해야 한다. 모두 `char buf[BUF_SIZE]`란 변수가 있고, 그 뒤에 `vuln` 함수를 부르기 전 저장해 두었던 `$esp`와 `$ebp`가 차례로 **8바이트**씩(64비트 환경에서 돌려서 그렇다. 32비트라면 4바이트를 썼겠지?) 스택에 저장되어 있다. 그러니까...

|content|size|stack direction|
|:-:|:-:|:-:|
|ebp|8 byte|↓|
|esp|8 byte|(stack grows downward)|
|buf|`BUF_SIZE` byte|(smaller address value downward)|

... 형태로 스택이 쌓여있는 거다(스택은 아래 방향으로 자라며, 따라서 아래로 내려갈수록 주소값이 작아진다). 아래에 있는 `buf`에게 `BUF_SIZE`의 크기보다 더 큰 길이로 하는 문자열 값을 넘겨주면 `$esp`와 `$ebp`의 값이 바뀔 수 있을 것이다.

## `bof6`

*여기에 코드 좀 넣어줘*

`vuln` 함수 안에 쉘코드가 `char shellcode[]` 형태로 이미 들어가 있다. `vuln` 함수를 종료할 때, 갖고 오게 될 `$ebp`의 값을 이 `SHELLCODE`가 위치한 주소값을 가지게끔 조작하면 될 것이다.

## `bof7`

*여기에 코드 좀 넣어줘*

`bof6`과는 다르게 이번엔 쉘코드가 들어가 있지 않다. 막막...하긴 했는데, 그냥 내가 입력으로 쉘코드를 넣어주고, `vuln` 함수를 종료하면서 갖고오게 될 `$ebp`의 값을 내가 입력한 문자열이 위치한 주소값이 되게끔 바꾸면 된다.

## `bof8`

*여기에 코드 좀 넣어줘*

이번엔 환경 변수 `SHELLCODE`를 `$ebp`가 가리키게 해야 한다. 근데 환경변수 `SHELLCODE`는 어떻게 만들까? 방법은...

1. 그냥 `bof8`을 실행할 때 마다 임시 환경변수를 등록하고 실행한다. (e.g. `SHELLCODE=<shellcode_main>> ./bof8)
2. `export` 명령어로 환경변수를 한번 등록해 놓고 `bof8`을 실행한다. (e.g. `export SHELLCODE=<shellcode_main>; ./bof8`)

둘 중 하나의 방법으로 하면 될 것이다. 나는 1번의 방법을 택했다.

추가. `SHELLCODE='\x31\xc0...' ./bof8`로는 실행이 불가능하다. 이렇게 쓰면 `SHELLCODE`에 쉘코드가 그대로 들어가지 않고 *저 문자 그대로(/비슷하게)* 들어가서 쉘코드가 아닌 게 되어버린다. 그래서, *진짜* 쉘코드를 주려면, `SHELLCODE=$(python -c "print '<shellcode_main>'") ./bof8`의 형태로, 그러니까 **파이썬에서 쉘코드를 출력하여** 그걸 `SHELLCODE`에 넘겨주어야 한다.

추가 2. `bof7`의 경우 argument로 넘겨 준 문자열의 길이에 따라 `buf`의 주소값이 달라진다. 정확하게 추적하기가 쉽지 않았다.

추가 3. `set $ZF = 6`, `set $eflags |= (1 << $ZF)`를 애용해야 할 거 같다. 정상적으로 입력값/패러미터를 넘겨줘도 `setreuid` / `setregid`에서 자꾸 오류가 뜨는 분기로 튀어버리곤 하였다.

# -- END --

