# Report. HW4.

## `crackme0x04`
  1. *숫자* `pw`(진짜 변수명은 아니고 그냥 이렇게 정했다)를 **문자열 형태**로 입력받는다.
  2. `pw`의 길이(자리 수)를 `n`이라고 하였을 때, `0 < i < n`인 `i`에 대하여, `pw[0 : (i + 1)]`에 있는 숫자들의 합이 **15**가 되는 `i`가 있어야 한다.
  
`crackme0x03`과는 다르게 `check`라는 프로시저(함수?)가 추가되었다. 여기선...

  1. `[ebp - 0xc]`( / `0xfff435dc`)에 반복자 i가 들어가는 것 같다. 얘가 `pw`의 길이(`strlen`으로 계산함)와 같을 경우 반복을 종료한다.
  2. 각 자리수에 있는 숫자 `pw[i]`를 `sscanf` 함수를 통하여 하나씩 입력받는다. 이 결과값은 `0xfff435e4` 주소에 저장된다.
  3. `[ebp - 8]`( / `0xfff435e0`)에 `0xfff435e4`에 저장된 값을 더해주고, 이것이 `0xf`, 그러니까 **15**랑 같은지 계속 확인한다.
    - 조건을 만족한 경우 "Password OK!"라는 메세지를 출력한다.
    - 조건을 만족하지 않는 경우 1의 반복자 `i`를 1 증가하고 다시 1로 돌아간다.

## `crackme0x05`
  1. `crackme0x04`와 동일하게, *숫자* `pw`를 **문자열 형태**로 입력받는다.
  2. `pw`의 길이(자리 수)를 `n`이라고 하였을 때, `0 < i < n`인 `i`에 대하여, `pw[0 : (i + 1)]`에 있는 숫자들의 합이 **16**이 되는 `i`가 있어야 한다.
  3. `pw`는 *반드시* **짝수**여야 한다.
  
`crackme0x04`에서 `parell`이란 프로시저(/함수?)  
