# Report. HW4.

## `crackme0x04`
  1. *숫자* `pw`(진짜 변수명은 아니고 그냥 이렇게 정했다)를 **문자열 형태**로 입력받는다.
  2. `pw`의 길이(자리 수)를 `n`이라고 하였을 때, `0 < i < n`인 `i`에 대하여, `pw[0 : (i + 1)]`에 있는 숫자들의 합이 **15**가 되는 `i`가 있어야 한다.
  
`crackme0x03`과는 다르게 `check`라는 프로시저(함수?)가 추가되었다. 여기선...

  1. `[ebp - 0xc]`( / `0xfff435dc`)에 반복자 i가 들어가는 것 같다. 얘가 `pw`의 길이(`strlen`으로 계산함)와 같을 경우 반복을 종료한다(5로 넘어감)
  2. 각 자리수에 있는 숫자 `pw[i]`를 `sscanf` 함수를 통하여 하나씩 입력받는다. 이 결과값은 `0xfff435e4` 주소에 저장된다.
  3. `[ebp - 8]`( / `0xfff435e0`)에 `0xfff435e4`에 저장된 값을 더해주고, 이것이 `0xf`, 그러니까 **15**랑 같은지 계속 확인한다.
  4. 3의 조건을 만족한 경우 "Password OK!"라는 메세지를 출력하고, `check`를 종료하며, 조건을 만족하지 않는 경우 1의 반복자 `i`를 1 증가하고 다시 1로 돌아간다.
  5. 4번이 이루어지지 않고 반복이 모두 끝났을 경우 "Password Incorrect!"를 출력한다.

## `crackme0x05`
  1. `crackme0x04`와 동일하게, *숫자* `pw`를 **문자열 형태**로 입력받는다.
  2. `pw`의 길이(자리 수)를 `n`이라고 하였을 때, `0 < i < n`인 `i`에 대하여, `pw[0 : (i + 1)]`에 있는 숫자들의 합이 **16**이 되는 `i`가 있어야 한다.
  3. `pw`는 *반드시* **짝수**여야 한다.
  
`crackme0x04`에서 `parell`이란 프로시저(/함수?)가 추가되었다. 여기선...

  1. `sscanf`를 통하여 `[ebp - 4]`( / `0xff8af5db`)에 `pw`를 숫자로 바꾼 값을 저장한다.
  2. 1에서 나온 숫자를 `eax`에 담아두고, 이걸 **`1과 bitwise AND 연산을 한`** 결과값을 다시 `eax`에 저장한다.
  3. 2에서 계산하여 나온 `eax` 값을 `test` instruction을 통해 `ZF`(zero flag)가 세워지는지 본다. 0일 경우 - 짝수일 경우 - "Password OK!" 메세지를 출력하고, 그렇지 않을 경우 "Incorrect Password!"를 출력한다.
