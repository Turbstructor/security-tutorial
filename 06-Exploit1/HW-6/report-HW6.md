# Report. HW6.

## `bof3`, `bof4`

## `bof5`

<details><summary>`bof5.c`</summary>
<p>
    
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#define BUF_SIZE 128
#define KEY 0x12345678
#define G "\033[32m"
#define Y "\033[33m"
#define E "\033[0m"

void vuln() {
    int innocent;
    char buf[BUF_SIZE];
    
    puts(G "enter your name :)" E);
    gets(buf);
    printf("Hello " Y "%s" E "!\n", buf);

    if (innocent == KEY) {
        if (setreuid(1006, 1006)) {
            perror("setuid");
            exit(1);
        }
        if (setregid(1006, 1006)) {
            perror("setgid");
            exit(1);
        }
        system(buf);
    }
}

int main(){
    vuln();
    return 0;
}
```

</p></details>

### 이전과의 차이점
- `bof4`는 argument로 문자열을 넘겨주었지만, 이번엔 *프로그램 내 입력*을 통하여 문자열을 넘겨주어야 한다.
- `system("/bin/sh")`을 통하여 BOF가 발생했을 경우 그 안에서 쉘을 실행하는 구문이 이번엔 `system(buf)`으로 바뀌었다. 그러니까, *입력을 통해* `/bin/sh`을 실행하여야 한다.

### 진행
그래서... 이번에도 `buf`와 `innocent` 간에 거리가 얼만큼 되는지 알아보아야 한다. *여기 좀 추가해줘요*

입력할 때 앞에 "/bin/sh; "를 붙여주자(그래야 쉘이 안에서 실행된다). 그리고... 중간에 있는 내용들은 #로 채워놓자(그래야 쉘이 실행되고 아무것도 실행하지 않게 - 중간에 채워놓은 #들 때문에 주석처리가 되어 아무것도 실행을 하지 않게 - 된다. 그 다음에 `innocent`에 들어갈 비교값 `0x12345678`을 **little-endian** 방식으로 입력을 시켜주고.

*사진 좀 넣어줘요*

성공했다. (`bof6` 비밀번호는 일부러 잘랐다)

# -- END --

