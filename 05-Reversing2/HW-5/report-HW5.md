# Report. HW5.

~~미세먼지 팁. 파일명에 샵(`#`)을 붙여서 이걸 링크로 걸려고 하면 링크에는 `%23`으로 바꿔줘야 한다. 그대로 놔 두면 얘가 "야 이거 없는데에에에에에에" 하는 이야기를 해 준다.~~

여기서는 둘 다 `radare2`를 사용하여 해결하였다.

## easyelf

### 1. 문장이 뭐가 있죠

우선 string들이 무엇이 있는지 확인해 보았다. ![`rabin2 -z easyelf` content](./easyelf_screenshots/easyelf_%231.png) `Correct!\n`, `Wrong\n`, 그리고 `Reversing.Kr Easy ELF\n\n` 이렇게 3개만 존재하는데, 앞의 2개는 각각 비밀번호를 맞췄을 떄와 틀렸을 때, 맨 뒤는 그냥 프로그램을 실행할 때 나오는 문장이다.

### 2. 함수가 뭐가 있죠

디버거 모드로 `radare2`를 킨 다음, `aa`("analyze all")를 치고 그 다음... 함수 리스트를 `afl`을 통하여 뽑아보았다. !['r2 -d easyelf'; aa; afl](./easyelf_screenshots/easyelf_%232.png) `main` 함수가 있으니, 여기서부터 시작을 해 보자. `dcu main`("continue until `main`) 다음 `Vpp` 명령어를 주면... 아래와 같은 코드가 나온다.

### 3. 코드(?)

!['dcu main'; Vpp](./easyelf_screenshots/easyelf_%234.png)

    0x0004853b      call sym.imp.write

이 부분까지는 처음 "Reversing.Kr Easy ELF\n\n"을 출력하는 부분이고... 바로 아래의

    0x00048540      call 0x8048434
    
부분으로 넘어가면...

![scanf](./easyelf_screenshots/easyelf_%236.png)

의

    0x08048434      push ebp
    0x08048435      mov ebp, esp
    0x08048437      sub esp, 0x18
    0x0804843a      mov eax, 0x8048650
    0x0804843f      mov dword [esp + 4], 0x804a020
    0x08048447      mov dword, [esp], eax
    0x0804844a      call sym.imp.__isoc99_scanf
    0x0804844f      leave
    0x08048450      ret
    
... 코드들이 나온다. 문자열을 입력받아 그 내용을 주소 `0x0804a020`...를 시작위치로 하여 넣고 나서 그렇게 다시 `main` 부분으로 돌아오면 다시 바로 아래의 

    0x08048545      call 0x8048451
    
... 부분이 나오는데, 안으로 들어가면...

![check?](./easyelf_screenshots/easyelf_%238.png)

의 각 글자들을 비교하는 코드가 나온다. 여기서 맨 마지막 글자의 위치가 5번째 글자, 그러니까 `0x0804a024` 주소란 걸 알 수 있는데, 이건...

    0x080484a8      movzx eax, byte [0x804a025]
    0x080484af      test al, al
    0x080484b1      je 0x80484ba
    
...의 부분에서 `test` 명령어를 통하여 `0x804a025` 부분에 `NULL` 문자(`0x00`)이 들어가 있는지를 체크하기 때문이다.

우선 코드상으로는 두번째 글자부터 확인을 하는데, (이 문자'만' 숫자라서 그런 게 아닐까 싶다)

    0x08048454      movzx eax, byte [0x804a021]
    0x0804845b      cmp al, 0x31
    0x0804845d      je 0x8048469
    
주소 `0x0804a021`에 들어가 있는 1바이트 문자가 `0x31` (`1`)인지 체크한다.

5번째 글자도 바로 알아볼 수 있는데,

    0x08048496  movzx eax, byte [0x804a024]
    0x0804849d  cmp al, 0x58
    0x0804849f  je 0x80484a8
    
... 부분에서 (XOR 암호화 없이) 바로 문자 `0x58`(`X`)와 비교를 진행하기 때문이다.

나머지 3개 글자들의 경우,

1. 원래의 문자를 XOR 암호화를 통해 바꾼 키로 대체한다.
2. 1에서 바뀐 키를 각각의 키와 비교한다.

... 순으로 한번에 - 암호화할 때 모든 3개 키들을 암호화하고 이후에 하나하나씩 비교를 진행 - 진행한다.

우선 3개 글자들을 암호화하는 코드들은

    0x080484**      movzx eax, byte [0x804a02*]
    0x080484**      xor eax, 0x**
    0x080484**      mov byte [0x804a02*], al

...으로 각 글자들을 XOR 연산을 취한 다음 바뀐 글자를 원래 글자가 있는 위치에 넣어두고,

    0x080484**      movzx eax, byte [0x804a02*]
    0x080484**      cmp al, 0x**
    0x080484**      je 0x80484**
    
...의 코드를 통해 이 바뀐 3글자들이 각각 특정 코드와 일치하는지를 본다. 여기서, 과제를 낸 그 수업시간의 내용을 언급하면, **"XOR 출력물에 다시 XOR 키를 적용하여 XOR 연산을 거치면 복호화된 데이터가 나오기"** 때문에, 이걸 적용하여 각 3개 글자에 대해 "암호화 후 출력물과 비교하는 코드", "XOR 키", "복호화된 데이터"를 표로 작성하면,

|index|address|XOR 출력물과 비교하는 코드|XOR 암호화에 쓴 키 코드|XOR "복호화"를 진행했을 때 나오는 코드|
|---|---|---|---|---|
|0|`0x0804a020`|`0x78`|`0x34`|`L`|
|2|`0x0804a022`|`0x7c`|`0x32`|`N`|
|3|`0x0804a023`|`0xdd`|`0xffffff88`|`U`|

가 나온다. 위의 내용을 모아보면, 첫번째 글자부터 차례대로 `L`, `1`(숫자), `N`, `U`, `X`의 입력이 들어가야 하는 것이다.

각각 글자들을 확인할 때 확인하려는 것과 일치하는 경우엔 다음 글자를 확인하는 과정으로 넘어가지만, 만약 아니라면... 항상,

    0x080484**      mov eax, 0
    0x080484**      jmp 0x80484f5
    
... 부분을 통해 `eax`를 `0`으로 바꾸고,

    0x080484f5      pop ebp
    0x080484f6      ret
    
자신이 불려졌던 곳으로 돌아가는 코드로 (바로) 넘어가게 된다. 하지만 만약 맨 마지막 - 코드 상으로는 4번째 글자를 확인하는 부분인데 - 글자를 비교하는 부분까지 전부 문제가 없었다(일치했다)고 하면,

    0x080484f0      mov eax, 1
    
...으로 `eax`를 `1`로 바꾼 다음 체크하는 부분이 불렸던 곳으로 돌아가게 된다.

![Is it OK?](./easyelf_screenshots/easyelf_%239.png)

이전에 문자를 비교하는 코드를 거치고 났다면 `eax`의 값이 `0`이나 `1` 중 하나의 값으로 정해져 있을 건데, 이 때 `0`을 가지고 있을 경우 `"Wrong"`을 출력하는

    0x08048554      mov eax, 0
    0x0804855b      mov dword [local_8h], 6
    0x08048563      mov dword [local_4h], str.Wrong
    0x0804856b      mov dword [esp], 1
    0x08048572      call sym.imp.write
    
    0x08048577      mov eax, 0
    ...
    
의 분기로 넘어간 후 프로그램을 종료하고,, 만약 `1`을 가지고 있었다면 `"Correct"`를 출력하는 분기

![It is OK](./easyelf_screenshots/easyelf_%2310.png)

`0x080484f7` ~ `0x0804851a` 코드로 넘어갔다가 돌아와서 프로그램을 종료한다.

## bomb - 노란 선 제거


