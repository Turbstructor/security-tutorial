# Report. HW5.

~~미세먼지 팁. 파일명에 샵(`#`)을 붙여서 이걸 링크로 걸려고 하면 링크에는 `%23`으로 바꿔줘야 한다. 그대로 놔 두면 얘가 "야 이거 없는데에에에에에에" 하는 이야기를 해 준다.~~

여기서는 둘 다 `radare2`를 사용하여 해결하였다.

## easyelf

### 1. 문장이 뭐가 있죠

우선 string들이 무엇이 있는지 확인해 보았다. ![`rabin2 -z easyelf` content](./easyelf_screenshots/easyelf_%231.png) `Correct!\n`, `Wrong\n`, 그리고 `Reversing.Kr Easy ELF\n\n` 이렇게 3개만 존재하는데, 앞의 2개는 각각 비밀번호를 맞췄을 떄와 틀렸을 때, 맨 뒤는 그냥 프로그램을 실행할 때 나오는 문장이다.

### 2. 함수가 뭐가 있죠

디버거 모드로 `radare2`를 킨 다음, `aa`("analyze all")를 치고 그 다음... 함수 리스트를 `afl`을 통하여 뽑아보았다. !['r2 -d easyelf'; aa; afl](./easyelf_screenshots/easyelf_%232.png) `main` 함수가 있으니, 여기서부터 시작을 해 보자. `dcu main`("continue until `main`) 다음 `Vpp` 명령어를 주면... 아래와 같은 코드가 나온다.

### 3. 코드(?)

!['dcu main'; Vpp](./easyelf_screenshots/easyelf_%234.png)

    0x0004853b      call sym.imp.write

이 부분까지는 처음 "Reversing.Kr Easy ELF\n\n"을 출력하는 부분이고... 바로 아래의

    0x00048540      call 0x8048434
    
부분으로 넘어가면...

![scanf](./easyelf_screenshots/easyelf_%236.png)

의

    0x08048434      push ebp
    0x08048435      mov ebp, esp
    0x08048437      sub esp, 0x18
    0x0804843a      mov eax, 0x8048650
    0x0804843f      mov dword [esp + 4], 0x804a020
    0x08048447      mov dword, [esp], eax
    0x0804844a      call sym.imp.__isoc99_scanf
    0x0804844f      leave
    0x08048450      ret
    
... 코드들이 나온다. 문자열을 입력받아 그 내용을 주소 `0x0804a020`...를 시작위치로 하여 넣고 나서 그렇게 다시 `main` 부분으로 돌아오면 다시 바로 아래의 

    0x08048545      call 0x8048451
    
... 부분이 나오는데, 안으로 들어가면...

![check?](./easyelf_screenshots/easyelf_%238.png)

의 각 글자들을 비교하는 코드가 나온다. 여기서 맨 마지막 글자의 위치가 5번째 글자, 그러니까 `0x0804a024` 주소란 걸 알 수 있는데, 이건...

    0x080484a8      movzx eax, byte [0x804a025]
    0x080484af      test al, al
    0x080484b1      je 0x80484ba
    
...의 부분에서 `test` 명령어를 통하여 `0x804a025` 부분에 `NULL` 문자(`0x00`)이 들어가 있는지를 체크하기 때문이다.

우선 코드상으로는 두번째 글자부터 확인을 하는데, (이 문자'만' 숫자라서 그런 게 아닐까 싶다)

    0x08048454      movzx eax, byte [0x804a021]
    0x0804845b      cmp al, 0x31
    0x0804845d      je 0x8048469
    
주소 `0x0804a021`에 들어가 있는 1바이트 문자가 `0x31` (`1`)인지 체크한다.

5번째 글자도 바로 알아볼 수 있는데,

    0x08048496  movzx eax, byte [0x804a024]
    0x0804849d  cmp al, 0x58
    0x0804849f  je 0x80484a8
    
... 부분에서 (XOR 암호화 없이) 바로 문자 `0x58`(`X`)와 비교를 진행하기 때문이다.

나머지 3개 글자들의 경우,

1. 원래의 문자를 XOR 암호화를 통해 바꾼 키로 대체한다.
2. 1에서 바뀐 키를 각각의 키와 비교한다.

... 순으로 한번에 - 암호화할 때 모든 3개 키들을 암호화하고 이후에 하나하나씩 비교를 진행 - 진행한다.

우선 3개 글자들을 암호화하는 코드들은

    0x080484**      movzx eax, byte [0x804a02*]
    0x080484**      xor eax, 0x**
    0x080484**      mov byte [0x804a02*], al

...으로 각 글자들을 XOR 연산을 취한 다음 바뀐 글자를 원래 글자가 있는 위치에 넣어두고,

    0x080484**      movzx eax, byte [0x804a02*]
    0x080484**      cmp al, 0x**
    0x080484**      je 0x80484**
    
...의 코드를 통해 이 바뀐 3글자들이 각각 특정 코드와 일치하는지를 본다. 여기서, 과제를 낸 그 수업시간의 내용을 언급하면, **"XOR 출력물에 다시 XOR 키를 적용하여 XOR 연산을 거치면 복호화된 데이터가 나오기"** 때문에, 이걸 적용하여 각 3개 글자에 대해 "암호화 후 출력물과 비교하는 코드", "XOR 키", "복호화된 데이터"를 표로 작성하면,

|index|address|XOR 출력물과 비교하는 코드|XOR 암호화에 쓴 키 코드|XOR "복호화"를 진행했을 때 나오는 코드|
|---|---|---|---|---|
|0|`0x0804a020`|`0x78` / `0111 1000`|`0x34` / `0011 0100`|`L` / `0x4c` / `0100 1100`|
|2|`0x0804a022`|`0x7c` / `0111 1100`|`0x32` / `0011 0010`|`N` / `0x4e` / `0100 1110`|
|3|`0x0804a023`|`0xdd` / `1101 1101`|`0xffffff88` / (맨 뒤 2자리만 바꿀 경우)`1000 1000`|`U` / `0x55` / `0101 0101`|

가 나온다. 위의 내용을 모아보면, 첫번째 글자부터 차례대로 `L`, `1`(숫자), `N`, `U`, `X`의 입력이 들어가야 하는 것이다.


... 각각 글자들을 확인할 때 확인하려는 것과 일치하는 경우엔 다음 글자를 확인하는 과정으로 넘어가지만, 만약 아니라면... 항상,

    0x080484**      mov eax, 0
    0x080484**      jmp 0x80484f5
    
부분을 통해 `eax`를 `0`으로 바꾸고,

    0x080484f5      pop ebp
    0x080484f6      ret
    
자신이 불려졌던 곳으로 돌아가는 코드로 (바로) 넘어가게 된다. 하지만 만약 맨 마지막 - 코드 상으로는 4번째 글자를 확인하는 부분인데 - 글자를 비교하는 부분까지 전부 문제가 없었다(일치했다)고 하면,

    0x080484f0      mov eax, 1
    0x080484f5      pop ebp
    0x080484f6      ret
    
으로 `eax`를 `1`로 바꾼 다음 체크하는 부분이 불렸던 곳으로 돌아가게 된다.

![Is it OK?](./easyelf_screenshots/easyelf_%239.png)

이전에 문자를 비교하는 코드를 거치고 났다면 `eax`의 값이 `0`이나 `1` 중 하나의 값으로 정해져 있을 건데, 이 때 `0`을 가지고 있을 경우 `"Wrong"`을 출력하는

    0x08048554      mov eax, 0
    0x0804855b      mov dword [local_8h], 6
    0x08048563      mov dword [local_4h], str.Wrong
    0x0804856b      mov dword [esp], 1
    0x08048572      call sym.imp.write
    
    0x08048577      mov eax, 0
    ...
    
의 분기로 넘어간 후 프로그램을 종료하고,, 만약 `1`을 가지고 있었다면 `"Correct"`를 출력하는 분기

![It is OK](./easyelf_screenshots/easyelf_%2310.png)

(사진 속) `0x080484f7` ~ `0x0804851a` 코드로 넘어갔다가 돌아와서 프로그램을 종료한다.

## bomb - 노란 선 제거

### 1. 문장이 뭐가 있죠

똑같이 `rabin2 -z` 명령어를 사용했는데,

![bomb_Strings](./bomb_screenshots/bomb_%231.png)

... 좀 많다. 

### 2. 함수가 뭐가 있죠

![bomb_functions](./bomb_screenshots/bomb_%232.png)

... 얘도 좀 많다. 원래 있는 함수들도 많이 쓰지만, 여기서 정의한 부분도 많은 것 같다. 우선 이번 과제는 "노란 선을 제거"하는 것만이니, `sym.yellow_preflight`, `sym_yellow`, `main` 중심으로 봐야 할 거 같다.

![bomb_main](./bomb_screenshots/bomb_%234.png)

메뉴를 출력하는 부분과 메뉴 선택을 물어오는 부분이다. `fgets`를 통해 입력을 받는데, 메뉴 번호 `1`을 입력해도, 메뉴 `yellow`를 입력해도(대소 무시) 노란색 선을 해제하는 부분으로 넘어간다.

![sym.yellow](./bomb_screenshots/bomb_%237.png)

`sym.yellow` 부분이다(처음에 `main`에서 시작하지 않고 `dcu sym.yellow`를 통하여 노란색 선을 제거하는 메뉴 입력을 주고 여기서부터 시작할 수도 있다). 이 뒤에...

    0x080497a1      leave
    0x080497a2      ret
    
...가 잘리긴 했지만, 키를 비교하고 동일할 경우 `"UNLOCK PASSWORD 1 ACCEPTED, LOCK DISENGAGED"`를 출력하는 부분만 있다. 비밀번호를 입력하는 부분은 당장은 안 보이는데,

    0x0804971f      call sym.yellow_preflight
    
에서 다루는 것 같아 여기 안으로 들어가 보니, 윗 사진 중 `0x080496e8` ~ `0x08049718` 주소의 코드들이 나온다. `fgets` 함수를 통하여 문자열을 입력하고 나면 다시 `sym.yellow`로 돌아가는데,

    0x080497**      movzx eax, byte [0x804c2**]
    0x080497**      cmp al, 0x**
    0x080497**      jne 0x804977c

8개 글자를 비교하는 모든 부분이 위와 같은 코드를 지닌다. `obj.buffer`의 주소는 `0x804c24c`로 나오고, 여기서부터 8개의 글자를 각각..

|index|주소|비교하는 글자|
|0|`0x804c24c`|`0x38` (`8`)|
|1|`0x804c24d`|`0x34` (`4`)|
|2|`0x804c24e`|`0x33` (`3`)|
|3|`0x804c24f`|`0x37` (`7`)|
|4|`0x804c250`|`0x31` (`1`)|
|5|`0x804c251`|`0x30` (`0`)|
|6|`0x804c252`|`0x36` (`6`)|
|7|`0x804c253`|`0x35` (`5`)|

...과 비교한다. `easyelf`때와는 다르게 여기선 XOR 암호화는 진행되지 않고, 바로 비밀번호가 `84371065`라는 것을 알 수 있었다.

easyelf와 비슷하게, 각각 글자를 비교하여 일치할 경우 다음 글자를 확인하는 순서로 넘어가지만, 만약 여기서 한 번이라도 비밀번호를 틀렸다면..

    0x0804977c      mov eax, dword obj.wire_yellow
    0x08049781      shl eax, 0xa
    0x08049784      mov dword obj.wire_yellow, eax
    0x08049789      jmp 0x80497a1
    ...
    0x080497a1      leave
    0x080497a2      ret
    
의 부분으로 바로 넘어간다.

전부 다 일치했다면, 위의 `0x0849789`에서 바로 `0x08497a1`으로 넘어가지 않고, 비밀번호가 일치하고 선을 끊었다는 메세지를 출력하는

    0x0804978b      mov dword [esp], str.e_43m__e_0m_e_33m_UNLOCK_PASSWORD_!_ACCEPTED__LOCK_DISENGAGED_e_0m
    0x08049792      call sym.imp.puts
    0x08049797      mov dword obj.wire_yellow, 0

의 코드 3줄을 거치고 `sym.yellow`가 호출되었던 주소로 돌아간다.
    


