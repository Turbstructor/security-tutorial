# 익스플로잇(2)

## bof5.c 

입력한 값이 버퍼와 `system` 함수에 들어가고 있다. 루트 쉘을 얻기 위해 입력값을 어떻게 설정해야 할까? 

**SERVER1** : `ssh bof5@ghostogether.club` 

**SERVER2** : `ssh bof5@ghostogether.club` 

## shellcode

말 그대로 쉘을 실행시킬 수 있는 코드이고, 그 코드를 문자열로 삽입할 수 있도록 기계어 코드로 만든 것이다. 

`setuid` 가 설정된 프로그램에서 `return address` 를 조작할 수 있을 때 쉘을 실행시킬 수 있는 어셈블리 코드를 문자열로 삽입하고 삽입된 문자열의 주소값으로 `return address` 를 조작한다. 

### Hello, World!!! 

지난주에 다음과 같은 문자열을 출력하는 어셈블리 코드를 코딩했었다. 

```assembly
global    _start                  
_start:                           
    mov       rax, 1             
    mov       rdi, 1            
    mov       rsi, message     
    mov       rdx, 16         
    syscall                  
message:                    
    db        "Hello, World!!!", 10
```

이러한 어셈블리어를 기계어로 컴파일 한 후에 기계어 코드를 헥사값으로 만들어보자. 

```shell
objcopy -O binary -j .text hello hello.hex
for hex in `od -A n -t x1 hello_nonull.hex`; do echo -nE "\x$hex"; done > shellcode.txt
```

그리고 이렇게 완성된 `shellcode.txt` 에는 그 어셈블리어에 대응되는 기계어가 헥사값으로 변환되어 있다. 이제 이 헥사값들을 C 프로그램에 집어넣어보자.

```shell
cat shellcode.txt >> shellcode_test.c
```

그리고 `shellcode_test.c` 를 다음과 같이 완성해보자. 

```c
char * shellcode = "\xb8\x01\x00\x00\x00\xbf\x01\x00\x00\x00\x48\xbe\xa5\x00\x40\x00\x00\x00\x00\x00\xba\x0d\x00\x00\x00\x0f\x05\xb8\x3c\x00\x00\x00\x48\x31\xff\x0f\x05\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x6f\x72\x6c\x64\x0a";

int main(void) {
    void (*fp)(void);
    fp = shellcode;
    fp();
    return 0;
}
```

`shellcode` 라는 문자열을 `void` 반환형이면서 매개변수 형태는 `void` 인 함수 포인터 `fp` 에 대입시켰다. 그리고 곧바로 호출하고 있다. 그러나 컴파일 하고 실행해봐도 "Hello, World" 가 출력되지 않는다. 그것은 `shellcode` 문자열이 `\x00` 널바이트를 만나서 `\xb8\x01`까지만 인식되고 나머지는 인식되지 않기 때문이다. 그러므로 어셈블리어를 수정해서 널 바이트가 생성되지 않도록 고쳐보자. 

```assembly
global    _start
_start:
    push    1
    pop     rax
    push    1
    pop     rdi
    mov     rbx, 0x0a212121646c726f
    push    rbx
    mov     rbx, 0x57202c6f6c6c6548
    push    rbx
    push    rsp
    pop     rsi
    push    16
    pop     rdx
    syscall
    push    60
    pop     rax
    xor     rdi, rdi
    syscall
```

`mov` 는 `push` 와 `pop` 을 활용해서 없애고 문자열도 헥사값 16 바이트를 꽉꽉 채워저 `mov` 명령어에 전달함으로써 널 바이트를 없앴다. 그리고 0 을 대입해야 하는 명령어는 `xor` 명령어를 사용한다. 이렇게 되면 널 바이트가 생성되지 않는다. 다시 컴파일하고 헥사값을 추출한 후 C 프로그램에 넣어보자. 

```c
char * shellcode = "\x6a\x01\x58\x6a\x01\x5f\x48\xbb\x6f\x72\x6c\x64\x21\x21\x21\x0a\x53\x48\xbb\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x53\x54\x5e\x6a\x10\x5a\x0f\x05\x6a\x3c\x58\x48\x31\xff\x0f\x05\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x6f\x72\x6c\x64\x0a";

int main(void) {
    void (*fp)(void);
    fp = shellcode;
    fp();
    return 0;
}
```

위와 같이 널바이트를 제거한 헥사코드를 문자열에 저장한 후 다시 함수포인터로 형변환 하고 호출하면 "Hello, World!!!" 가 잘 출력된다. 

### shellcode 생성

위와 같은 원리로 Hello, World!!! 를 출력하는 것이 아닌 쉘을 실행시킬 수 있는 코드를 헥사코드로 변환하고 널 바이트를 제거하면 쉘을 실행시킬 수 있는 코드라고 해서 `shellcode` 라고 한다. 실질적인 쉘 코드를 만들기에는 시간이 부족하기 때문에 인터넷이 있는 쉘코드를 갖다가 쓰도록 하자. 

http://shell-storm.org/shellcode/files/shellcode-806.php

이 링크에 보면 누군가가 쉘 코드를 야무지게 만들어놓았다. 리눅스 x64 아키텍쳐 용 쉘 코드이니 바로 갖다가 쓸 수 있는 쉘 코드이다. 

### shellcode 를 BOF 를 통해 스택에 삽입하기 

![shellcode BOF](http://staff.ustc.edu.cn/~bjhua/courses/fall10/labs/lab2/a.jpg)

이렇게 만들어진 쉘 코드를 위와 같이 스택에 삽입한 후 쓰레기 값을 얼마정도 넣어서 리턴 어드레스 직전까전 닿게 한다. 그리고 리턴 어드레스를 쉘코드가 있는 곳의 주소값으로 덮어써버린다. 그러면 프로그램은 쉘 코드의 주소값으로 뛰게 되고 해커는 권한이 없는 쉘을 얻게 된다!  

![shellcode BOF2](https://image1.slideserve.com/3344372/buffer-overflow-cont1-l.jpg)

## bof6.c bof7.c bof8.c 

bof6.c bof7.c bof8.c 를 풀어봅시다.

---

## 과제 

### 과제 가이드 

1. [HW-7.md](HW-7/HW-7.md) 파일의 지시를 따르는 것이 과제이다. (발표를 하며 설명을 할 수 있어야 합니다)

2. 과제 파일은 [HW-7](HW-7) 디렉토리에 만들어야 한다. 

3. 과제 파일이 완성되면 다음 명령어를 참고하여 완성된 과제를 푸쉬한다. 

```shell
cd /path/to/security
git add .
git commit -m "complete HW-7"
git push -u origin master
```

4. 마지막으로 `pull requests` 를 한다. 
